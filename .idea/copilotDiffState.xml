<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/content/blog/spring-jpa-auditor-aware-always.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/content/blog/spring-jpa-auditor-aware-always.md" />
              <option name="originalContent" value="---&#10;author: StevenPG&#10;pubDatetime: 2025-07-26T12:00:00.000Z&#10;title: Why I Always Set Up AuditorAware in Spring JPA&#10;slug: always-set-up-auditor-aware-spring-jpa&#10;featured: true&#10;ogImage: /assets/default-og-image.png&#10;tags:&#10;  - software&#10;  - spring boot&#10;  - java&#10;  - jpa&#10;description: AuditorAware is a powerful feature in Spring JPA that allows you to automatically populate auditing fields like createdBy and lastModifiedBy. In this post, I explain why I always set it up in my projects and how it can simplify your code.&#10;---&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="---&#10;author: StevenPG&#10;pubDatetime: 2025-07-26T12:00:00.000Z&#10;title: Why I Always Set Up AuditorAware in Spring JPA&#10;slug: always-set-up-auditor-aware-spring-jpa&#10;featured: true&#10;ogImage: /assets/default-og-image.png&#10;tags:&#10;  - software&#10;  - spring boot&#10;  - java&#10;  - jpa&#10;description: AuditorAware is a powerful feature in Spring JPA that allows you to automatically populate auditing fields like createdBy and lastModifiedBy. In this post, I explain why I always set it up in my projects and how it can simplify your code.&#10;---&#10;&#10;# Brief&#10;&#10;My goal is to make posts like this the SIMPLEST place on the internet to learn how to do things&#10;that caused me trouble. That way, if this is found, someone doesn't have to do the same digging I had to do.&#10;&#10;In every Spring Boot project I work on, one of the first things I do after setting up JPA is configure `AuditorAware`. &#10;This post covers why this should be a standard practice and exactly how to set it up.&#10;&#10;# Why You Should Always Set This Up&#10;&#10;## Compliance and Legal Requirements&#10;Many industries require detailed audit trails. Whether you're working in finance, healthcare, or any regulated industry, &#10;knowing who modified what and when isn't just nice to have—it's mandatory. Setting up auditing from day one saves you &#10;from painful retrofitting later.&#10;&#10;## Debugging and Troubleshooting&#10;When production issues arise, audit fields become your best friend. Being able to trace changes back to specific users &#10;can cut debugging time from hours to minutes. I've saved countless hours by having this information readily available.&#10;&#10;## Security and Accountability&#10;In today's security-conscious world, having a clear trail of who made changes is crucial for incident response and &#10;forensic analysis. It's also a deterrent against malicious behavior when users know their actions are tracked.&#10;&#10;## Zero Code Overhead&#10;Once configured, JPA auditing works automatically. You don't need to remember to set these fields manually—Spring &#10;handles it transparently. This eliminates human error and ensures consistency across your entire application.&#10;&#10;# The Setup&#10;&#10;Here's everything you need to get AuditorAware working with Spring JPA!&#10;&#10;## Dependencies&#10;&#10;First, ensure you have the necessary dependencies in your `build.gradle` or `pom.xml`:&#10;&#10;```groovy&#10;dependencies {&#10;    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'&#10;    implementation 'org.springframework.boot:spring-boot-starter-security'&#10;}&#10;```&#10;&#10;## Enable JPA Auditing&#10;&#10;Add the `@EnableJpaAuditing` annotation to your main application class:&#10;&#10;```java&#10;@SpringBootApplication&#10;@EnableJpaAuditing(auditorAwareRef = &quot;auditorProvider&quot;)&#10;public class Application {&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(Application.class, args);&#10;    }&#10;}&#10;```&#10;&#10;## Create an Auditable Base Entity&#10;&#10;Create a base entity that other entities can extend:&#10;&#10;```java&#10;@MappedSuperclass&#10;@EntityListeners(AuditingEntityListener.class)&#10;public abstract class AuditableEntity {&#10;    &#10;    @CreatedDate&#10;    @Column(name = &quot;created_date&quot;, nullable = false, updatable = false)&#10;    private LocalDateTime createdDate;&#10;    &#10;    @LastModifiedDate&#10;    @Column(name = &quot;last_modified_date&quot;)&#10;    private LocalDateTime lastModifiedDate;&#10;    &#10;    @CreatedBy&#10;    @Column(name = &quot;created_by&quot;, updatable = false)&#10;    private String createdBy;&#10;    &#10;    @LastModifiedBy&#10;    @Column(name = &quot;last_modified_by&quot;)&#10;    private String lastModifiedBy;&#10;    &#10;    // Getters and setters&#10;    public LocalDateTime getCreatedDate() {&#10;        return createdDate;&#10;    }&#10;    &#10;    public void setCreatedDate(LocalDateTime createdDate) {&#10;        this.createdDate = createdDate;&#10;    }&#10;    &#10;    public LocalDateTime getLastModifiedDate() {&#10;        return lastModifiedDate;&#10;    }&#10;    &#10;    public void setLastModifiedDate(LocalDateTime lastModifiedDate) {&#10;        this.lastModifiedDate = lastModifiedDate;&#10;    }&#10;    &#10;    public String getCreatedBy() {&#10;        return createdBy;&#10;    }&#10;    &#10;    public void setCreatedBy(String createdBy) {&#10;        this.createdBy = createdBy;&#10;    }&#10;    &#10;    public String getLastModifiedBy() {&#10;        return lastModifiedBy;&#10;    }&#10;    &#10;    public void setLastModifiedBy(String lastModifiedBy) {&#10;        this.lastModifiedBy = lastModifiedBy;&#10;    }&#10;}&#10;```&#10;&#10;## Implement AuditorAware&#10;&#10;Create an implementation of `AuditorAware` that returns the current user:&#10;&#10;```java&#10;@Component(&quot;auditorProvider&quot;)&#10;public class SpringSecurityAuditorAware implements AuditorAware&lt;String&gt; {&#10;    &#10;    @Override&#10;    public Optional&lt;String&gt; getCurrentAuditor() {&#10;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();&#10;        &#10;        if (authentication == null || &#10;            !authentication.isAuthenticated() || &#10;            authentication instanceof AnonymousAuthenticationToken) {&#10;            return Optional.of(&quot;system&quot;);&#10;        }&#10;        &#10;        return Optional.of(authentication.getName());&#10;    }&#10;}&#10;```&#10;&#10;## Use the Auditable Base Entity&#10;&#10;Now, extend your entities from the auditable base:&#10;&#10;```java&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User extends AuditableEntity {&#10;    &#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false, unique = true)&#10;    private String email;&#10;    &#10;    @Column(nullable = false)&#10;    private String firstName;&#10;    &#10;    @Column(nullable = false)&#10;    private String lastName;&#10;    &#10;    // Constructors, getters, and setters&#10;}&#10;```&#10;&#10;That's it! Now every time you save or update a User entity, the audit fields will be automatically populated.&#10;&#10;# Advanced Use Cases&#10;&#10;## Using UUID for User Identification&#10;&#10;For better security and to avoid exposing usernames, you might want to use UUIDs:&#10;&#10;```java&#10;@Component(&quot;auditorProvider&quot;)&#10;public class UuidAuditorAware implements AuditorAware&lt;UUID&gt; {&#10;    &#10;    @Override&#10;    public Optional&lt;UUID&gt; getCurrentAuditor() {&#10;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();&#10;        &#10;        if (authentication == null || !authentication.isAuthenticated()) {&#10;            return Optional.empty();&#10;        }&#10;        &#10;        // Assuming your UserPrincipal has a getUserId() method&#10;        if (authentication.getPrincipal() instanceof UserPrincipal) {&#10;            UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();&#10;            return Optional.of(userPrincipal.getUserId());&#10;        }&#10;        &#10;        return Optional.empty();&#10;    }&#10;}&#10;```&#10;&#10;## Custom Audit Fields&#10;&#10;Sometimes you need additional audit information like IP addresses:&#10;&#10;```java&#10;@MappedSuperclass&#10;@EntityListeners(AuditingEntityListener.class)&#10;public abstract class ExtendedAuditableEntity {&#10;    &#10;    // Standard audit fields&#10;    @CreatedDate&#10;    private LocalDateTime createdDate;&#10;    &#10;    @LastModifiedDate&#10;    private LocalDateTime lastModifiedDate;&#10;    &#10;    @CreatedBy&#10;    private String createdBy;&#10;    &#10;    @LastModifiedBy&#10;    private String lastModifiedBy;&#10;    &#10;    // Additional audit fields&#10;    @Column(name = &quot;created_from_ip&quot;)&#10;    private String createdFromIp;&#10;    &#10;    @Column(name = &quot;last_modified_from_ip&quot;)&#10;    private String lastModifiedFromIp;&#10;    &#10;    @PrePersist&#10;    protected void onCreate() {&#10;        this.createdFromIp = getCurrentUserIp();&#10;    }&#10;    &#10;    @PreUpdate&#10;    protected void onUpdate() {&#10;        this.lastModifiedFromIp = getCurrentUserIp();&#10;    }&#10;    &#10;    private String getCurrentUserIp() {&#10;        // Implementation to get current user's IP address&#10;        // This could be from request context or a custom service&#10;        return &quot;127.0.0.1&quot;; // Placeholder&#10;    }&#10;}&#10;```&#10;&#10;# Testing Your Setup&#10;&#10;Here's how to test that your auditing is working correctly:&#10;&#10;```java&#10;@SpringBootTest&#10;@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)&#10;class AuditingTest {&#10;    &#10;    @Autowired&#10;    private UserRepository userRepository;&#10;    &#10;    @Test&#10;    @WithMockUser(username = &quot;testuser&quot;)&#10;    void testAuditFieldsArePopulated() {&#10;        // Given&#10;        User user = new User();&#10;        user.setEmail(&quot;test@example.com&quot;);&#10;        user.setFirstName(&quot;John&quot;);&#10;        user.setLastName(&quot;Doe&quot;);&#10;        &#10;        // When&#10;        User savedUser = userRepository.save(user);&#10;        &#10;        // Then&#10;        assertThat(savedUser.getCreatedDate()).isNotNull();&#10;        assertThat(savedUser.getCreatedBy()).isEqualTo(&quot;testuser&quot;);&#10;        assertThat(savedUser.getLastModifiedDate()).isNotNull();&#10;        assertThat(savedUser.getLastModifiedBy()).isEqualTo(&quot;testuser&quot;);&#10;    }&#10;}&#10;```&#10;&#10;# Common Gotchas&#10;&#10;## Forgetting to Enable Auditing&#10;Always remember to add `@EnableJpaAuditing` to your configuration. Without it, the audit annotations won't work.&#10;&#10;## Missing EntityListener&#10;Don't forget `@EntityListeners(AuditingEntityListener.class)` on your auditable entities or base class.&#10;&#10;## Null User Context&#10;Always handle cases where there might not be an authenticated user, especially in background jobs or system operations.&#10;&#10;## Time Zone Issues&#10;Be consistent with your time zone handling. Consider using UTC for audit timestamps and converting to local time zones only for display.&#10;&#10;# Wrapping Up&#10;&#10;Setting up `AuditorAware` in Spring JPA is a small upfront investment that pays huge dividends throughout the life of your application. &#10;It provides essential audit trails, improves debugging capabilities, and ensures compliance with various regulatory requirements.&#10;&#10;The setup is straightforward, the maintenance overhead is minimal, and the benefits are substantial. Make `AuditorAware` setup &#10;a standard part of your Spring Boot project initialization checklist. Your future self (and your team) will thank you for it." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>